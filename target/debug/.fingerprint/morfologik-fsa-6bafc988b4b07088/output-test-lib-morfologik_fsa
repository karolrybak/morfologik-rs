{"$message_type":"diagnostic","message":"unreachable expression","code":{"code":"unreachable_code","explanation":null},"level":"warning","spans":[{"file_name":"crates/morfologik-fsa/src/iterator.rs","byte_start":6969,"byte_end":6973,"line_start":140,"line_end":140,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"        None // Stack is empty","highlight_start":9,"highlight_end":13}],"label":"unreachable expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/morfologik-fsa/src/iterator.rs","byte_start":1606,"byte_end":6960,"line_start":45,"line_end":139,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        loop {","highlight_start":9,"highlight_end":15},{"text":"            // Peek at the top of the stack to see which node and arc to process.","highlight_start":1,"highlight_end":82},{"text":"            // We use `last_mut` to be able to update the `Option<ArcOffset>` (next sibling).","highlight_start":1,"highlight_end":94},{"text":"            let (current_node_on_stack, next_arc_to_try_ref) = match self.stack.last_mut() {","highlight_start":1,"highlight_end":93},{"text":"                Some(top) => (top.0, &mut top.1), // top.0 is Node, top.1 is Option<ArcOffset>","highlight_start":1,"highlight_end":95},{"text":"                None => return None, // Stack is empty, DFS is complete.","highlight_start":1,"highlight_end":73},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let arc_to_process_opt = next_arc_to_try_ref.take(); // Take the arc, leaving None for this node's turn","highlight_start":1,"highlight_end":116},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if let Some(arc) = arc_to_process_opt {","highlight_start":1,"highlight_end":52},{"text":"                // We are processing 'arc' from 'current_node_on_stack'.","highlight_start":1,"highlight_end":73},{"text":"                // Before going deeper, put its *next sibling* back onto the stack for later.","highlight_start":1,"highlight_end":94},{"text":"                if let Ok(false) = self.fsa.is_arc_terminal(arc) { // If current arc is not the last from its node","highlight_start":1,"highlight_end":115},{"text":"                    if let Ok(next_sibling_arc) = self.fsa.get_next_arc(arc) {","highlight_start":1,"highlight_end":79},{"text":"                        // This assignment is to the stack frame we are currently looking at.","highlight_start":1,"highlight_end":94},{"text":"                        // When this arc's processing (and its children's) is done,","highlight_start":1,"highlight_end":84},{"text":"                        // the loop will pick up this next_sibling_arc.","highlight_start":1,"highlight_end":72},{"text":"                        *next_arc_to_try_ref = Some(next_sibling_arc);","highlight_start":1,"highlight_end":71},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    // If get_next_arc fails (e.g. NoNextArc, which shouldn't happen if not terminal),","highlight_start":1,"highlight_end":103},{"text":"                    // or if is_arc_terminal errored, then None remains, and this node's siblings are done.","highlight_start":1,"highlight_end":108},{"text":"                } // If it was terminal, None correctly remains.","highlight_start":1,"highlight_end":65},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let label = match self.fsa.get_arc_label(arc) {","highlight_start":1,"highlight_end":64},{"text":"                    Ok(l) => l,","highlight_start":1,"highlight_end":32},{"text":"                    Err(e) => {","highlight_start":1,"highlight_end":32},{"text":"                        // Error getting label, current path is corrupted.","highlight_start":1,"highlight_end":75},{"text":"                        // Pop the current_sequence label that was *about* to be added or was from parent.","highlight_start":1,"highlight_end":107},{"text":"                        // This state is tricky; best to return error.","highlight_start":1,"highlight_end":71},{"text":"                        // The stack will be popped in the next iteration if this was the only arc.","highlight_start":1,"highlight_end":100},{"text":"                        return Some(Err(e));","highlight_start":1,"highlight_end":45},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"                self.current_sequence.push(label);","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let is_final = match self.fsa.is_arc_final(arc) {","highlight_start":1,"highlight_end":66},{"text":"                    Ok(f) => f,","highlight_start":1,"highlight_end":32},{"text":"                    Err(e) => { self.current_sequence.pop(); return Some(Err(e)); }","highlight_start":1,"highlight_end":84},{"text":"                };","highlight_start":1,"highlight_end":19},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                let mut sequence_yielded_for_this_arc: Option<FsaResult<Vec<u8>>> = None;","highlight_start":1,"highlight_end":90},{"text":"                if is_final {","highlight_start":1,"highlight_end":30},{"text":"                    sequence_yielded_for_this_arc = Some(Ok(self.current_sequence.clone()));","highlight_start":1,"highlight_end":93},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // Try to go deeper: push children of the current arc's target node to stack.","highlight_start":1,"highlight_end":94},{"text":"                let mut pushed_children = false;","highlight_start":1,"highlight_end":49},{"text":"                match self.fsa.get_end_node(arc) {","highlight_start":1,"highlight_end":51},{"text":"                    Ok(target_node) => {","highlight_start":1,"highlight_end":41},{"text":"                        match self.fsa.get_first_arc(target_node) {","highlight_start":1,"highlight_end":68},{"text":"                            Ok(first_child_arc) => {","highlight_start":1,"highlight_end":53},{"text":"                                self.stack.push((target_node, Some(first_child_arc)));","highlight_start":1,"highlight_end":87},{"text":"                                pushed_children = true;","highlight_start":1,"highlight_end":56},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                            Err(FsaError::InvalidNodeOffset(_)) => { /* Target is a leaf, no children to push */ }","highlight_start":1,"highlight_end":115},{"text":"                            Err(e) => { // Error getting children","highlight_start":1,"highlight_end":66},{"text":"                                self.current_sequence.pop(); // Backtrack label","highlight_start":1,"highlight_end":80},{"text":"                                return sequence_yielded_for_this_arc.or(Some(Err(e)));","highlight_start":1,"highlight_end":87},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    Err(e) => { // Error getting end node","highlight_start":1,"highlight_end":58},{"text":"                        self.current_sequence.pop(); // Backtrack label","highlight_start":1,"highlight_end":72},{"text":"                        return sequence_yielded_for_this_arc.or(Some(Err(e)));","highlight_start":1,"highlight_end":79},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                if sequence_yielded_for_this_arc.is_some() {","highlight_start":1,"highlight_end":61},{"text":"                    // If we yielded a sequence, and we are *not* going deeper from this arc's target,","highlight_start":1,"highlight_end":103},{"text":"                    // we need to pop the current label because we are done with this path.","highlight_start":1,"highlight_end":92},{"text":"                    // If we *are* going deeper, the pop will happen when that deeper path is exhausted.","highlight_start":1,"highlight_end":105},{"text":"                    if !pushed_children {","highlight_start":1,"highlight_end":42},{"text":"                        self.current_sequence.pop();","highlight_start":1,"highlight_end":53},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                    return sequence_yielded_for_this_arc;","highlight_start":1,"highlight_end":58},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                // If not final, and we didn't push children (it's a non-final leaf for this path)","highlight_start":1,"highlight_end":99},{"text":"                if !is_final && !pushed_children {","highlight_start":1,"highlight_end":51},{"text":"                    self.current_sequence.pop(); // Backtrack this label","highlight_start":1,"highlight_end":73},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                // Continue the loop: if children were pushed, they'll be processed.","highlight_start":1,"highlight_end":85},{"text":"                // Otherwise, the (now None) arc option for current_node_on_stack will cause a pop.","highlight_start":1,"highlight_end":100},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                // No more arcs to try from current_node_on_stack (next_arc_to_try_opt_mut was None).","highlight_start":1,"highlight_end":102},{"text":"                // This means we have processed all children of this node. Time to backtrack.","highlight_start":1,"highlight_end":94},{"text":"                self.stack.pop(); // Pop (current_node_on_stack, None)","highlight_start":1,"highlight_end":71},{"text":"                if !self.current_sequence.is_empty() {","highlight_start":1,"highlight_end":55},{"text":"                    // Pop the label that led to current_node_on_stack","highlight_start":1,"highlight_end":71},{"text":"                    self.current_sequence.pop();","highlight_start":1,"highlight_end":49},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":"any code following this expression is unreachable","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_code)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unreachable expression\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/morfologik-fsa/src/iterator.rs:140:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        loop {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // Peek at the top of the stack to see which node and arc to process.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            // We use `last_mut` to be able to update the `Option<ArcOffset>` (next sibling).\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let (current_node_on_stack, next_arc_to_try_ref) = match self.stack.last_mut() {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m139\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12many code following this expression is unreachable\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m140\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m        None // Stack is empty\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munreachable expression\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unreachable_code)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `current_node_on_stack`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"crates/morfologik-fsa/src/iterator.rs","byte_start":1806,"byte_end":1827,"line_start":48,"line_end":48,"column_start":18,"column_end":39,"is_primary":true,"text":[{"text":"            let (current_node_on_stack, next_arc_to_try_ref) = match self.stack.last_mut() {","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"crates/morfologik-fsa/src/iterator.rs","byte_start":1806,"byte_end":1827,"line_start":48,"line_end":48,"column_start":18,"column_end":39,"is_primary":true,"text":[{"text":"            let (current_node_on_stack, next_arc_to_try_ref) = match self.stack.last_mut() {","highlight_start":18,"highlight_end":39}],"label":null,"suggested_replacement":"_current_node_on_stack","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `current_node_on_stack`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/morfologik-fsa/src/iterator.rs:48:18\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let (current_node_on_stack, next_arc_to_try_ref) = match self.stack.last_mut() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_current_node_on_stack`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"2 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 2 warnings emitted\u001b[0m\n\n"}
